CS255 Project 1 Milestone 1 README
==================================

1) Secure Key Storage Database

The group keys are stored as follows: The user is prompted at the start of
each Facebook session for a passphrase. The passphrase is then stored in 
ephemeral storage (sessionStorage) which we assume to be secure, along with
two randomly generated salts, one for encryption and the other for MAC'ing.

Applying PBKDF2 to the passphrase and the salt results in two 128-bit keys
(one for encryption, E_enc, and the other for HMAC, E_hmac) which we assume to 
be secure and which have as much entropy as the password of the user.

When a set of keys for a new group is generated via the GetRandomValues function,
we store those keys in the extension's localStorage in an encrypted and
authenticated manner, using AES-CTR-128 and CBC-MAC to ensure that the keys
are secure and not tampered with.

Since we are using industry standard encryption and assuming that our underlying
cryptoprimitives are secure, the group keys will be as secure as the passphrase
chosen by the user.

Accessing the keys consists of wiping out any information floating around
from previous sessions, retrieving the key from sessionStorage, computing the
derived keys with the random salts stored in session storage, and attempting
to decrypt the database using the derived key. 

If the passphrase is wrong, then the derived keys will be very different,
since PBKDF2 will generate different keys for different phrases. This will
cause the HMAC authentication step in decrypting the encrypted and authenticated
string to fail, a prompt will be assumed alerting the user to this fact.

We have chosen 10000 rounds for PBKDF2 as we believe it to be a large enough
value for the kind of security we are looking for. We also used 128-bit values
for the salt for additional security.

2) New Key Generation

We use the cryptographic primitives provided by Google Chrome and other Webkit 
browsers with the window.crypto.getRandomValues function, as suggested by the
handout, to generate a 128-bit encryption key and a 128-bit MAC key, which we
then concatenate and base64 encode to present to the user as a printable string
using the window.btoa function offered by Chrome.

We assume the underlying CSPRNG offered by Chrome is secure, and thus our key
generation algorithm is simple and secure as well.

3) Encrypt and Decryption Functions

We chose to implement AES-CTR-128 for encryption and decryption because of its
simplicity and ease of implementation. When encrypting, we use a random
128-bit nonce which is stored in plaintext near the beginning of the
message, just before the encrypted ciphertext. The usual birthday
calculation shows that we expect to see some nonce twice after 2^56
draws. We think the probability of one key being used 2^56 times is
sufficiently low that this is not a problem.

In addition to the nonce, the length of the message in plaintext is
prepended to the beginning of the message (so our message format is length
(4-bytes) || nonce (16-bytes) || message blocks) as a defense against
attacks involving appending extra text to the end of a message, and its
integrity is protected by CBC-MAC (which we do not discuss here). This
enforces the fact that no two messages will be sent for which one is a
prefix of the other, which is necessary for CBC-MAC.

Our actual encryption key is completely randomly generated by the GenerateKey
function as detailed in Section 2. 

As in standard CTR, we pass the key and the sum of the nonce and a counter
to AES, then xor the result with the appropriate block of the plaintext
message. Decryption consists of reading off the message length and the nonce, using
the given key and the nonce to recreate the AES stream, and xoring with
the ciphertext. Since we know the intended length of the message, we stop when we've gone
through enough blocks to see the whole message. This is a further defense
against text being appended by an attacker. If the decryption fails, no
information is revealed to the user.

We note that counter mode is one of two recommended block cipher modes
(the other being CBC), with no known weaknesses as long as the block
cipher is secure, which AES on 128-bit keys is believed to be.

4) Message Authentication Code

(Not discussed in Milestone 1)

5) Comments about Cryptography in the Browser

Cryptography in the browser is hard to implement well for a couple of reasons:

 - Ill-defined language. The JavaScript language is almost singularly unsuitable
   for cryptography applications with dynamic typing and weird floating point/integer
   mix of operations in the standard. Using a statically type language would almost
   definitely make mistakes easier to catch.

 - Vulnerability from timing attacks. Modern JavaScript engines are very fast and
   very good at optimizing away redundant code in order to make itself faster. Although
   this is good in general, it is bad for cryptography code since it can make our
   cryptography code vulnerable to timing attacks as delay loops and other mitigation
   factors are optimized away by the JavaScript engine.

 - Large attack surface. Web browsers have to support a variety of extensions and
   formats. Vulnerabilities in any one of these components may expose the entire
   web browser and render all cryptography done on that web browser useless.

 - Javascript Secure Delivery. Javascript cannot be securely delivered to a browser
   in the face of an active network attacker without some other secure protocol (such
   as TLS or SSL). This presents a chicken-and-egg problem in a pure JavaScript
   cryptography environment.

 - Vulnerability to XSS / CSRF attacks. The platform itself is also vulnerable to XSS
   and CSRF attacks from insecure websites, even though they may have employed some
   sort of JavaScript cryptography.

6) How could this implementation be circumvented if someone "really wanted
to"?

The implementation could be circumvented in a number of different ways
if someone had the resources:

 - Active network attackers can run ssl_strip and inject malicious javascript
   to read off the decryption after the script runs.

 - Keyloggers can be used to capture the passphrase used by the user

 - The hardware, operating system, browser and Facebook itself consist of the 
   trusted computing base, which has to be secure, benign and free from any compromise
   for the system to be secure. An attacker compromising any one of the above would 
   be able to view the decrypted messages and capture keystrokes with relative
   ease.

 - Finally "Rubber-hose cryptanalysis" could be applied to the user him/herself 
   as well. 
